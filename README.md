```
XRP Ledger Proposed Standard #5-L

Title:       Tagged Addresses ("Loosely" Packed)
Author:      Elliot M. Lee
Affiliation: Ripple
Created:     2019-06-18
```

## Abstract

Destination tags provide a way for exchanges, payment processors, corporates or entities which accept incoming payments, escrows, checks and similar transactions to use a single receiving wallet while being able to disambiguate incoming transactions by instructing the senders to include a destination tag.

This draft presents a way of encoding a tagged address: an address that contains both the target wallet as well as a destination tag as a single unit.

## Motivation

Although flexible, destination tags suffer from several drawbacks.

Communicating a destination tag to users can be a problem for a number of reasons:

- In the absence of a standard format to represent an (address, tag) pair, different users of destination tags communicate the information in different ways.
- Users needs to enter two items, usually in two distinct input fields which may be inconsistently or confusingly named (e.g. one implementation refers to the destination tag as a "PIN").
- Programmers need to decide on how, when or even if the "Destination Tag" field must be surfaced, complicating panel layouts and increasing the potential for user confusion.
- The tag is an opaque identifier, generated by and meaningful only to the entity that will be receiving funds. Tags do not include a checksum to prevent against a user accidentally omitting or transposing digits or otherwise incorrectly entering a tag.

This proposal seeks to address this problem by defining a standard format to represent an (address, tag) which:

- Is expressed as a single string that shares all the desirable properties of existing addresses, including the ability to be selected by double-clicking on them.
- Eliminates the need for a separate "Destination Tag" field by allowing a single format to represent addresses both with and without tags.
- Includes a built-in checksum as a form of error-checking to reduce the probability that a typographical error will generate a correct address.

Furthermore, this new format distinguishes between production (aka mainnet) and test (aka test net or altnet).

## Limitations

We are not looking to change the on-ledger format; that is, the new style addresses can't be used for fields where an `AccountID` is expected in the binary format. Instead, the packed address will be detected and decoded at higher levels (for example, by the client software, `ripple-lib` or the RPC and WebSocket APIs in `rippled`), verified and then split into distinct fields (e.g. `sfDestination` and `sfDestinationTag`) as appropriate, to assemble the underlying transaction.

This new address style incorporates the destination tag and a network ID. By updating software to understand such packed addresses, we improve the UX, while intelligently unpacking such addresses into their constituent parts for the underlying system.

## Options

Although we have options in developing a new format, including what encoding to use, ideally the resulting addresses will be similar to existing addresses to reduce the likelihood of user confusion as much as possible and, ideally, not requiring developers to implement a new codec.

Given this constraint, we need to use the Base58Check encoding, leaving us with two options:

1. A "tightly packed" format, where the address and tag are encoded using Base58Check as a single unit.
2. A "loosely packed" format, where the address is encoded using Base58Check and the destination tag is encoded separately and appended to the address.

The advantage of the "loose" format is that a portion (or substring) of the tagged address will precisely match the classic address. The "tight" format results in an address that shares no common characters with the classic address, except, perhaps, by chance.

This is a massive security advantage because it prevents a malicious actor from modifying the address in the conversion step without being detected. While not all users will care for this level of security, many advanced users will take advantage of this feature to visually observe that the tagged address contains the expected classic address and tag.

Furthermore, the format adds three additional benefits:
1. The network ID distinguishes addresses intended for production from those intended for test.
2. The checksum comes near the beginning of the address. Since the checksum is built on SHA256, it changes dramatically with any small change in the classic address and/or tag and/or network ID. This allows users to distinguish addresses by looking at them, if necessary.
3. A tagged address is clearly distinct from a classic address because of its dissimilar initial letter. This is a huge benefit from a UX perspective because it is easy to distinguish tagged addresses from classic addresses, which will be necessary because not all software will immediately accept tagged addresses in all of the places where classic addresses are currently accepted. This point will be elaborated upon later in this document.

As will be shown below, the format proposed here is not complex to detect, encode, or decode.

Though it is a "loose" format in the sense that the classic address and tag are readable within the new encoding, these tagged addresses can be used as a full replacement for classic addresses in end-user UIs.

Regardless of whether we choose a "tightly packed" or "loosely packed" format, developers will always need to be aware of the classic addresses and destination tags because they are used in the ledger itself, in transaction signing, and in transaction parsing and accounting.

## Status

This is only a proposal. It is intended to generate discussion between developers, community members and other interested parties, in hopes that that we will reach consensus on the way forward.

Comments, criticisms, suggestions and improvements are welcome!

## Proposal

### Addresses and Destination Tags

For a better introduction to addresses and tags, it may help to reference https://developers.ripple.com/accounts.html.

### Existing Format

Currently, an address is generated by base58-encoding (with a checksum) a 21 byte buffer:

`[← 1 byte prefix →|← 160 bits of account ID →]`

The chosen byte prefix is `TokenType::AccountID` (value 0)

This base58-encoded string is referred to as a "classic address".

### Proposed format

In the proposed format, the following values are concatenated together:

1. An initial character indicating the network ID.
2. A base58-encoded checksum, calculated in a very similar manner to a classic address's checksum.
3. A delimiter, chosen to be '0'.
4. A tag.
5. A classic address.

#### 1. Network ID

This character is chosen to be 'X' for production and 'T' for test. For this reason, tagged addresses following this format are referred to as "X addresses" as shorthand.

#### 2. Checksum

The checksum is calculated with the following steps.
1. Decode the account ID from the classic address.
2. Encode the tag as a little endian 32-bit unsigned integer. If no tag should be used, encode this as zero bytes (effectively omitting it in step 4).
3. Encode the network ID character as one byte. Since the only network IDs are 'X' and 'T', `utf8` and `ascii` encoding yield the same result.
4. Concatenate these values: `Buffer.concat([accountID, tagBuffer, networkByte])`
5. Run the data through a double SHA256 hash. The checksum is the first 4 bytes.

Encode these 4 bytes in base58 using the same alphabet used to encode classic addresses.

#### 3. Delimiter

The delimiter prevents ambiguity between the checksum and the tag, making parsing simpler. It must be a character that does not appear in our base58 alphabet, so it can only be '0' or 'l'. With this specification, '0' is chosen.

#### 4. Tag

The tag is included as-is, converted to a string. For example, a tag of `16781933` becomes "16781933" inside the resulting X address. This makes parsing simple, and aids user recognition, improving the UX.

64-bit tags can be supported by including them as-is (in decimal format, the same way that 32-bit tags are represented).

If no tag should be used, this section is omitted from the X address.

#### 5. Classic address

The classic address is included as-is. Yes, the account ID is 'checked' by two different checksums as a result. Practically, this redundancy is harmless, and also benefits users and developers by reinforcing the 1:1 correspondence between an X address's account ID and a classic address.

### Encoding Example

In the following table, we present how the classic address `rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf` would be encoded under this spec to include various destination tags. The tag, if any, is on the left most column, followed by the tagged address. The network ID of these tagged addresses implies that they are intended for use in production.

| Tag | Address |
| None | XfHcYHS0rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 0 | XsjB8w300rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 1	| Xhc7pRF01rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 2	| XMYug202rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 32 | XprE6Cc032rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 276	| XhUFrT50276rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 65591	| XnS2ERt065591rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 16781933 | XaBvy71016781933rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 4294967294 | XhvyoXq04294967294rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 4294967295 | Xhd1vK404294967295rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |

In the following table, we present tagged address encodings for the same classic address (`rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf`) but with a network ID of 'test' to show the example of tagged addresses intended for use on the XRP Ledger Test Net.

| Tag | Address |
| None | Tsm3WnY0rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 0 | TfhBmod00rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 1	| TaXnCXj01rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 2	| Ta22v8c02rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 32 | T6iWHh032rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 276	| TfEjTTW0276rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 65591	| TatCaGC065591rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 16781933 | ThCV9Bh016781933rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 4294967294 | TaVQHik04294967294rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |
| 4294967295 | ThzQNmY04294967295rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf |

The command line utility included with this proposal can be used to generate the above examples:
```
./x-address-macos rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf undefined test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 0 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 1 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 2 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 32 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 276 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 65591 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 16781933 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 4294967294 test rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf 4294967295 test
```

### Advantages

Both the account ID and the destination tag are protected by the 32-bit checksum.
We can determine whether the address is packed by examining the initial character of the address: if it is `X` or `T` it is a packed address which may include a tag; if it is `r` it does not. If the initial character is anything else, the address is malformed.

The packed address's "suffix" is the same as the unpacked address, which can be useful and comforting to users (since it is clear which classic address is encoded by the packed address).

This consistency can be especially helpful for users in the context of trust lines, where the issuer of an asset must be explicitly trusted.

### Disadvantages

Support for X addresses must be added to client software, which may take time.

Fortunately, users will be able to easily tell if the address they want to use is an X address or not, simply by looking at the first character.

Exchanges etc. can use explanatory verbiage such as: "We have added support for X addresses."

If "X address" sounds too colloquial, they can say: "We have added support for tagged addresses." or "We have added support for packed addresses." However, this may be less informative since it is not immediately obvious how to tell whether an address is tagged/packed or not.

### Transaction Example

Consider the following transaction submission:

```
rippled submit secret '{
    "TransactionType":"Payment",
    "Account":"r3kmLJN5D28dHuH8vZNUZpMC43pEHpaocV",
    "Amount":"200000000",
    "Destination":"XhUFrT50276rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf"
}'
```

The server would unpack `XhUFrT50276rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf` to `rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf` and a destination tag of 276, and process the submission as if it had been:

```
rippled submit secret '{
    "TransactionType":"Payment",
    "Account":"r3kmLJN5D28dHuH8vZNUZpMC43pEHpaocV",
    "Amount":"200000000",
    "Destination":"rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf",
    "DestinationTag":276
}'
```

Obviously the server cannot do this when presented with a pre-signed transaction, although assembling and signing a transaction using an unexpanded packed address shouldn't be possible, since the binary encoding of an AccountID requires exactly 20 bytes.

Third party tools that accept user input should allow users to enter such addresses and transparently expand them prior to signing and/or submitting.

## Questions

Below is a list of questions to be addressed as a result of this requirements document:

### Should the format include both a source and a destination tag?

Probably not. It's better to simply state that the new format specifies an "address and tag" and to allow such addresses to be used both as a source and as a destination, and to decide the tag's type (source or destination) based on the field.

### Can we craft an encoding so that a packed address shares commonality with the actual address?

Yes, this proposal does this by encoding the classic address and destination tag separately and fusing the two components. Furthermore, the decoding process is not very complicated.

### There's potential for confusion. Can we help?

Users may not understand the semantics of a packed address sufficiently. This means that errors or confusion are possible as a result. Two exchange users might wonder why their deposit addresses are now different. Or one user may ask a friend what the deposit address is and, unknowingly, deposit funds into their friend's account.
The first is obviously not a problem with existing addresses, and the second is less likely to be an issue than these single addresses. The UX of third parties that choose to use the new format will have to make it clear to users that the address is unique for them.

The server could add information to the metadata associated with a transaction to help tools to map addresses. For example, the server could add the following:

```
"TaggedAddresses": [
    { 
        "XhUFrT50276rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf": {
            "Address": "rGWrZyQqhTp9Xu7G5Pkayo7bXjH4k4QYpf",
            "Tag": 276
        }
    }
]
```

### Why not BECH32?

The BECH32 format is great and has several advantages over Base58, including speed. We are defining a new address encoding here, so why not just go for that? It's an option, but we decided to be conservative and not require new code to be written or incorporated into servers, clients and libraries.

### What happens if someone specifies one of these addresses in the binary format?

The short answer is that they can't. The serialization field only allows exactly 20 bytes, so only the account itself can fit in. This format is only for base58 encoded addresses and is purely a convenience for users.

### Should we integrate this natively into the protocol?

No. It would be a huge change and, potentially, breaking one and there aren't any advantages that I can see. There are many risks. Allowing APIs to understand the new format sufficiently to decompose it into its two constituent fields should be sufficient.

## Sample TypeScript/JavaScript Implementation

The following is an example of a TypeScript function which will encode an address in a tag in a way that complies with this specification:

```ts
// 1. Decode classicAddress to accountID
const accountID: Buffer = decodeAccountID(this.classicAddress);

// 2. Encode networkID
let myNetworkByte: Buffer;
if (this.networkID === 'production') {
  myNetworkByte = Buffer.from('X');
} else if (this.networkID === 'test') {
  myNetworkByte = Buffer.from('T');
} else {
  throw new Error(`Invalid networkID: ${this.networkID}`);
}
const networkByte = myNetworkByte;

// 3. Convert tag to Buffer (UInt32LE)
let myTagBuffer: Buffer;
if (this.tag !== undefined) {
  if (Number.isInteger(this.tag) === false) {
    throw new Error(`Invalid tag: ${this.tag}`);
  }
  myTagBuffer = Buffer.alloc(8);
  myTagBuffer.writeUInt32LE(this.tag, 0);
} else {
  myTagBuffer = Buffer.alloc(0);
}
const tagBuffer: Buffer = myTagBuffer;

// 4. Concat accountID, tagBuffer, and networkByte to create payload
const payload = Buffer.concat([accountID, tagBuffer, networkByte]);

// 5. SHA256 x 2 and take first 4 bytes as checksum
const checksum = sha256(sha256(payload)).slice(0, 4);

// 6. Encode the checksum in base58
const checksum_base58 = codec.encode(checksum);

// 7. Decide to use '0' as our delimiter. It must be a character that
//    does not appear in our base58 alphabet, so it can only be '0' or 'l'
const DELIMITER = '0';

// 8. Form the "X Address" and return it:
//    - Start with 'X' or 'T' to make the address format obvious;
//    - Lead with the checksum so that any (valid) change to the
//      address/tag/network changes the first several characters of
//      the resulting address;
//    - Append the tag next for easy parsing.
//      To get the tag, take everything between DELIMITER and 'r'
//      (since a classic address will always start with 'r').
//      Notice that if we had put the tag after the address, we would
//      need to add a second delimiter to avoid ambiguity: the numbers
//      1-9 are all valid base58 characters in our alphabet.
//      An added benefit of this approach is that the tag, in the middle
//      of the string, (correctly) appears to be opaque and not user-editable.
//    - Finish with the classic address.
const tagString = this.tag !== undefined ? this.tag.toString() : '';
return new XAddress(networkByte.toString() + checksum_base58 + DELIMITER + tagString + this.classicAddress);
```

This requires some supporting code; please [view the full example here](./src/x-address.ts).
